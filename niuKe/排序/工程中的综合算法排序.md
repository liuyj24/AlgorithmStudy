> 引入:当我们使用某种语言封装好的排序方法时, 其底层是怎么实现的? 比如说在java中调用Arrays.sort()
### 一
> 如果排序的是基本数据类型, 用快排  
如果排序的不是基本数据类型, 用归并  
原因:
- 这关乎排序算法的稳定性. 快排是O(nlogn)的排序算法中最快的, 常数项低, 由于基础数据类型排序不要求稳定性, 所以使用快排.
- 归并排序在排序中能保持稳定性, 所以当对非基本数据类型数据进行排序的时候, 使用归并排序.

### 二 
> 无论是快排还是归并, 在递归环节都不会使用递归, 而是使用迭代的方式代替.   
根据老师的话, 我一开始是这样理解的:

- 系统使用递归需要准备递归函数, 准备递归函数的时间复杂度虽为O(1), 但是常数项很大, 比较浪费时间.
- 系统中有一块栈空间用于执行程序, 这个栈空间在根据系统调优后不会分配得很大, 大概几百兆的样子.  
如果我们使用迭代的话, 假设迭代的过程是一个函数, 我们只需要在调用迭代函数的时候为迭代函数在栈内存上分配一块栈帧. 至于迭代函数运行时需要使用很大的空间, 那没关系, 8g的内存都能给她使用.   
但是如果我们使用递归的话, 在递归里面每调用一次递归函数, 就要在栈内存中压入这一次递归的栈帧, 这样栈内存很容易就满了, 程序也挂了. 再加上如果递归函数不仅要使用栈内存, 其函数内部还要使用大量空间的话, 那就比较麻烦了.

### 三
> 无论是归并还是快排, 都会有个左右边界的处理, 也就是L,R指针. 当左右边界之差小于60的时候, 系统不会跑快排, 而是直接调用插入排序. 只有当左右边界之差大于60的时候, 会对边界进行二分. 原因:

- 插入排序虽然是时间复杂度为O(n^2)的算法, 但是它的常数项非常小, 在样本量不大的时候, 插入排序执行的飞快.