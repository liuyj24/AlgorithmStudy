### Manacher
> 在一个字符串中求最长的回文子串. 比如"abc1221def"返回4.

- 经典算法中存在什么问题?
- 传统思路 : 遍历每个字符, 从每个字符扩展开, 看看回文字符有多长. 
```
字符串:    1 2 3 2 1
长度  :    1 1 5 1 1
```
- 但是上面的办法解决不了偶回文串的问题. 
```
字符串:    1 2 2 1
长度  :    1 1 1 1
```
- 偶回文串用这个解法解出来是错误的. 
- 为了解决这个问题, 经典算法在每个字符之间添加一个虚轴, 依然是暴力去求每个字符展开得到回文串长度, 最后把最长的值除以2即得到答案. 
```
字符串:    1 2 1 3 3 1 2 1
加虚轴:    # 1 # 2 # 1 # 3 # 3 # 1 # 2 # 1 # 
长度  :    3 1 1 3 1 3 1 3 17....
max : 17 / 2 = 8
```
- 在上面的方法中, 我们添加的虚轴可以是原字符串中的任意字符, 因为在扩展算回文量时, 我们发现无论怎么比较都是实轴和实轴在比较或是虚轴和虚轴比较. 两者互不干扰, 所以虚轴是什么都行. 
> 经典算法的时间复杂度是多少?
- 每一个字符都要展开, 每个展开时最坏情况会到边界, 比如说一个字符串全部是1, 那就近似一个等差数列. 时间复杂度O(N^2)
---

### Manacher算法, 时间复杂度O(n)
> 和KMP一样先奠定概念. 

1. 回文直径和回文半径
```
............@............
|--回文半径--|
|-------回文直径--------|
比如 : # 1 # 2 # 1 #
回文直径是7, 回文半径是4.
```
2. 回文半径数组.   
我们建立一个和原字符串等长的数组, 对应每一个字符, 数组中记录的是对应字符的回文半径, 等数组处理完了, 返回其中的最大值即可. 
3. 回文最右右边界.   
```
字符串  # 1 # 2 # 1 #
下标    0 1 2 3 4 5 6
设置一个变量R, 记录回文最右右边界
一开始0下标, 回文子串长度为1, 最右边界在0, R=0
下标为1, 回文子串最右端来到2下标, 更新最右边界为2, R=2
到了下标为2, 回文子串最右端还是下标2, 最右右边界不变, R=2
```
4. 最右回文右边界对应中心点的位置.   
也就是回文最右右边界是由哪个中心点扩出来的.  
我们需要一个变量C记录最右回文边界对应的中心点的位置, 比如说上面的例子中R = 6, 对应C = 3.  
如果同时出现多个中心点对应最右回文右边界, 中心点的位置就取第一个. 
---
- 计算回文半径数组的伪代码描述 :   
```
情况1 :   
R没有包住i, 传统暴力扩展求回文半径.   
情况2 :  
R包住了i, 情况继续分支
    a) i'区在L, R内. O(1)的时间复杂度得出i的回文半径
    b) i'区超过L, R. O(1)的时间复杂度得出i的回文半径
    c) i'区左边界压中L, 不能直接得出i的回文半径, 要从i继续扩. 
```
情况2分支的描述图 : 
![image](0BAFD4BBCE13450C902CB12E249D882E)

> 时间复杂度分析 : 

- 首先看情况二的1,2两点. 时间复杂度均为O(1), 假设全部操作都中了这两个情况, 最终会收敛到O(n).
- 然后看情况一, 情况1虽然是暴力扩, 如果扩失败了很快便停止了. 如果扩成功了, 会导致R增大, R增大意味着进入情况二中的1, 2的次数更多了. 
- 情况二的3也是如此, i从R开始扩, 会导致R增大, R增大同样导致进入情况二中1,2的次数多了. 
- R是一个只增不减的, 最终整体时间复杂度会收敛于O(n).



```
public class Code_04_Manacher {
    public static char[] manacherString(String str) {
        char[] charArr = str.toCharArray();
        char[] res = new char[str.length() * 2 + 1];//加一是因为我们加虚轴的时候是前后都加.
        int index = 0;
        for (int i = 0; i != res.length; i++){
            res[i] = (i & 1) == 0 ? '#' : charArr[index++];
        }
        return res;
    }

    public static int maxLcpsLength(String str){
        if (str == null || str.length() == 0){
            return 0;
        }
        char[] charArr = manacherString(str);
        int[] pArr = new int[charArr.length];
        int C = -1;
        int R = -1;
        int max = Integer.MIN_VALUE;
        for (int i = 0; i < pArr.length; i++){
            pArr[i] = R > i ? Math.min(pArr[2 * C - i], R - i) : 1;//这一句超级秒, min中搞定了情况二中的3种情况, 外面的1搞定了情况1
            while(i + pArr[i] < pArr.length && i - pArr[i] > -1){
                if (charArr[i + pArr[i]] == charArr[i - pArr[i]]){
                    pArr[i]++;
                }else{
                    break;
                }
            }
            if (i + pArr[i] > R){
                R = i + pArr[i];
                C = i;
            }
            max = Math.max(max, pArr[i]);
        }
        return max - 1;//max记录的是最大右边界, 在创建加虚轴的数组时为了保证前后都有虚轴人为地给数组长度加一, 最后当然要减一.
    }

    public static void main(String[] args) {
        String str1 = "abc1234321ab";
        System.out.println(maxLcpsLength(str1));
    }
}
```