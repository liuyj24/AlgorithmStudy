### 窗口
> 窗口的运动轨迹描述

```
假设有一个数组 [2, 3, 5, 3, 7, 8, 2, 6, 8]
假设有两个指针l和r. l和r代表的就是窗口的边界, 一开始他们都指向0位置. 
r右移1格时, 窗口内的值加入一个2---|2|
r再往右移动一个格, 窗口内的值加入一个3---|2 3|
l往左移动一个格, 窗口内的减少2---|3|
*** l不能在r的右边
```
> 窗口内最大最小值更新结构是什么?

- 以最大值为例, 上面的轨迹中一开始窗口内的最大值为2, 3进来以后最大值更新为3. 照这么看每次更新窗口的最大值都要遍历一次窗口中的数, 有没有不用遍历的方式能获得窗口中最大值的结构? 

> 双端队列

- 双端队列可以从头加入或弹出一个数, 也可以从尾部加入或弹出一个数. 时间复杂度都是O(1).

- 窗口内添加元素的流程, 假设是窗口内最大值结构(双端队列从大到小, 如果是最小值结构则从小到大) : 
```
假设有 5 3 6 2 6 这几个数, l, r在头
下标 : 0 1 2 3 4
以下说的是具体的元素, 可以用下标对应
[] :    开始双端队列为空, 直接添加
[5] :   添加3, 3<5, 3添加到队尾
[5 3] : 添加6, 发现3<6, 把3从队尾弹出, 永远不找回;
[5] :   仍然是添加6, 发现5<6, 把5从队尾弹出, 永远不找回; 
[] :    队列为空, 6直接入队
[6] :   添加2, 2小于6, 插入
[6 2] : 添加6, 2<6, 2从队尾弹出, 永远不找回
[6] :   添加6, 6=6, 没有严格按照由大到小的顺序, 把6从队尾弹出, 不找回
[] :    添加6.
```
- 窗口内减少数的逻辑, 仍以更新最大值窗口为例
```
数组 [7 5 3 9]
假设现在双端队列中的元素为[7 5 3]
对应下标                   0 1 2 
当l左移一个格, 窗口内元素减少一个的时候, 也就是0位置的7过期了
到双端队列中比对一下, 看看头节点是不是过期元素的下标, 此时队列中为[0 1 2] , 是就把它从头部弹出. 

如果窗口中有7 5 3 9四个元素
根据双端队列的结构, 队列中只有3下标(指向9), 也就是当窗口减少一个元素的时候, 看看头结点是不是过期元素的下标
0 != 3, 结果不是, 就不弹出
```

#### 结论:窗口中的最大值就是双端队列头结点下标对应的值

> 原理如下:

```
- 假设现在有数组和窗口[|5 4| 3 ]
                      0  1  2
```
- 这时双端队列中的值为[5 4], 为什么4可以添加进队列? 因为窗口现在的最大值是下标为1的5. 如果窗口减少1个元素, 最大值将会是1下标的4. 也就是说4有可能成为窗口的最大值, 所以保存它. 
```
假设3也加入到窗口中[|5 4 3|]
                    0 1 2 
                     
```
- 和上面一样, 由于3有可能成为窗口的最大值, 所以要把它加入双端队列
```
假设这个时候加入一个6 : [|5 4 3 6|]
                         0 1 2 3
```
双端队列会更新为[6], 为什么要把比6小的元素都弹出队列? 因为下标对应的6会比5 4 3中任意一个数都晚过期, 而且值还比他们大, 5 4 3完全没有留下来的必要了. 
```
假设现在进入一个3 : [|5 4 3 6 3|]
```
- 双端队列[6 3]
```
假设现在进入一个6 : [|5 4 3 6 3 6|]
```
双端队列中的[6 3]都要弹出队列, 新来的6进入队列, 为什么? 原来的6下标3比新来的6下标5小, 证明它会更早过期, 新来的6比它的晚过期, 值还和它一样, 旧的6完全没有留下来的必要. 

> 这个结构的好处:

- 获得最大值的时间复杂度为O(1).
- 每个数只进一次, 出一次
- 如果窗口划过n个数, 更新的代价就是O(n), 每个数更新的平均时间复杂度是O(1), 但不是每个数都是O(1), 有时候更新一个数要把好几个数弹出队列, 但是平均下来是O(1), 所以总体是O(n).

---
### 题目 : 生成窗口最大值数组
> 有一个整形数组arr和一个大小为w的窗口从数组的最左边滑到最右边, 窗口每次向右滑一个位置. 
例如 : 数组为{4, 3, 5, 4, 3, 3, 6, 7}, 窗口的大小为3时:

```
[4 3 5] 4 3 3 6 7       窗口中的最大值为5
4 [3 5 4] 3 3 6 7       窗口中的最大值为5
4 3 [5 4 3] 3 6 7       窗口中的最大值为5
4 3 5 [4 3 3] 6 7       窗口中的最大值为4
4 3 5 4 [3 3 6] 7       窗口中的最大值为6
4 3 5 4 3 [3 6 7]       窗口中的最大值为7
```
> 如果数组的长度为n, 窗口的大小为w, 则一共产生n-w+1个窗口的最大值.   
请实现一个函数:  
输入 : 整形数组arr, 窗口大小为w
输出 : 一个长度为n-w+1的数组res, res[i]表示每一种窗口下的最大值.   
以本题为例, 结果应该返回{5, 5, 5, 4, 6, 7}

- 注 : 准备一个双向链表作为双端队列. LinkedList的底层就是双向链表. LinkedList中存的是下标. 值直接从arr中取出. 

> 代码

```
public class SlidingWindowMaxArray {

    public static int[] getMaxWindow(int[] arr, int w){
        if (arr == null || w < 1 || arr.length < w){
            return null;
        }
        LinkedList<Integer> qmax = new LinkedList<Integer>();//LinkedList底层用的是双向链表, 可以模拟双向队列.
        int[] res = new int[arr.length - w + 1];//题目给出的最终结果的长度, 可以自己计算推一下.
        int index = 0;
        for (int i = 0; i < arr.length; i++){//遍历每一个元素
            while(!qmax.isEmpty() && arr[qmax.getLast()] <= arr[i]){//当窗口添加一个元素的时候, 要判断这个元素是否比双端队列中最后的值大, 如果是的话, 最后的值舍弃
                qmax.pollLast();
            }
            qmax.addLast(i);//双端队列中保存的是下标.
            if (qmax.peekFirst() == i - w){//双端队列的头节点保存的是最大值, 假设窗口的长度为3, 我们要保证一个最大值不能出现3次, 因为窗口是每次滑动的.
                qmax.pollFirst();//这段if语句相当于把窗口的l边界不断往左移.
            }
            if (i >= w - 1){//这段if循环判断窗口的长度有没有到达题目的要求, 比如3, 窗口的长度为3, 每遍历一次就要输出一个最大值到结果数组.
                res[index++] = arr[qmax.peekFirst()];
            }
        }
        return res;
    }

    public static void printArray(int[] arr) {
        for (int i = 0; i != arr.length; i++) {
            System.out.print(arr[i] + " ");
        }
        System.out.println();
    }

    public static void main(String[] args){
        int[] arr = {4, 3, 5, 4, 3, 3, 6, 7};
        int w = 3;
        printArray(getMaxWindow(arr, 3));
    }
}
```
