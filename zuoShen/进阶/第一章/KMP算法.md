### KMP算法

> 俗称字符串查找算法. 

> 为什么要有这个算法?  
在没有KMP算法之前, 查找某个字符串(长为M)是不是在另外一个字符串中(长为N)时, 会从N字符串的首字母开始, 匹配字符串M. 在最坏的情况下, 字符串N中的每个字符都要匹配一次, 最终还找不到, 时间复杂度为O(M + N
)

> KMP算法想把时间复杂度将为O(N), 也就是只和字符串N的长度有关.

- 掌握KMP算法前先要奠定一个概念 : **一个字符串的最大前后缀相同子串**. 这个概念是KMP算法的精华, 其他利用KMP算法思想的题目也是利用这个概念. 
- KMP算法的实现思路要写出来真的很难, 如果要讲述的话需要配合画图, 希望能够牢牢地记在脑海里, 不断使用其思想加深印象. 代码中有详细解释.
- KMP算法得基本解题步骤是基于暴力匹配的, 只是通过求出模板字符串每个字符前面部分的前后缀, 得出一个next[]数组来优化整个查找过程. 同时找到next[]数组也需要技巧. 

> 具体代码如下 : 

```
public class KMP {

    public static int getIndexOf(String s, String m){
        if (s == null || m == null || m.length() < 1 || s.length() < m.length()){
            return -1;
        }
        char[] str1 = s.toCharArray();
        char[] str2 = m.toCharArray();
        int i1 = 0;
        int i2 = 0;
        int[] next = getNextArray(str2);
        while(i1 < str1.length && i2 < str2.length){//只要i1或i2中一个越界了, 证明匹配结束.
            if (str1[i1] == str2[i2]){//这个和暴力匹配一样, 如果第一个元素匹配中了, i1和i2同时移动继续匹配.
                i1++;
                i2++;
            }else if (next[i2] == -1){//这是特殊的情况:现在i2在str2的开头位置, 但是str1中i1不能匹配上str2头部, i1++继续匹配.
                i1++;
            }else{
                i2 = next[i2];//next[i2]中保存着i2位置中的前缀子串大小, 把这个大小作为下标, 正好对应着前缀子串的后面一个元素, 这个元素将和下一次循环中i1位置的值比较. 牛逼
            }
        }
        return i2 == str2.length ? i1 - i2 : -1;//如果上面的循环是因为i2越界退出的, 证明匹配到了字符串, 返回匹配开始的位置i1-i2, 否则返回-1匹配失败.
    }

    private static int[] getNextArray(char[] ms) {
        if (ms.length == 1){
            return new int[]{-1};
        }
        int[] next = new int[ms.length];
        next[0] = -1;//人为规定第一个元素的next值为-1
        next[1] = 0;//认为规定第二个元素的next值为0
        int i = 2;//从第三个元素开始在循环中计算next值
        int cn = 0;//按上下文判断 : 代表前缀子串的最后一个元素, 或者是最后一个元素的后面一个元素
        while(i < ms.length){
            if (ms[i - 1] == ms[cn]){//为什么是ms[i - 1], 我们现在求i位置元素的前后缀, 而要判断i位置前一个元素(后缀末尾元素)和前缀末尾元素是否相等
                next[i++] = ++cn;//如果相等的话, 证明前后缀相等, 把++cn这个代表前缀子串长度的值填入next[i], 同时i++了, cn也同时移动到下一个前缀的末尾, 超级妙这句.
            }else if (cn > 0){//进行到这证明ms[i-1]!=ms[cn], 我们拿到cn位置的next值, 再重新进入循环看能不能求得前后缀子串.
                cn = next[cn];
            }else{
                next[i++] = 0;//来到这里证明i位置没有前后缀子串, 求下一个位置.
            }
        }
        return next;
    }

    public static void main(String[] args){
        String str = "abcabcababaccc";
        String match = "ccc";
        System.out.println(getIndexOf(str, match));
    }
}
```

> 时间复杂度分析. 

- 其实也就两部分关键代码决定了时间复杂度, 第一处如下 :   
假设str1的长度为n, 循环中i1在变, 假设循环中还有i1 - i2这个量(这是一种解题方法, 不是说不能用i2, 只是用了i2很难判断执行的次数, 用i1 - i2替代更好. )  
i1最大能取到n, i1 - i2最大也能取到n, 下面我们看循环中3个分支的情况. 

```
    i1(max:n)   i1 - i2
1 : 变大        不变
2 : 变大        变大
3 : 不变        变大
```
这两个变量的结果最终都能到达n, 假设都能到达最大值也就是2n, 合起来就是O(n)

```
        while(i1 < str1.length && i2 < str2.length){//只要i1或i2中一个越界了, 证明匹配结束.
            if (str1[i1] == str2[i2]){//这个和暴力匹配一样, 如果第一个元素匹配中了, i1和i2同时移动继续匹配.
                i1++;
                i2++;
            }else if (next[i2] == -1){//这是特殊的情况:现在i2在str2的开头位置, 但是str1中i1不能匹配上str2头部, i1++继续匹配.
                i1++;
            }else{
                i2 = next[i2];//next[i2]中保存着i2位置中的前缀子串大小, 把这个大小作为下标, 正好对应着前缀子串的后面一个元素, 这个元素将和下一次循环中i1位置的值比较. 牛逼
            }
        }

```
---
- 第二个地方如下, 同样的道理
- 准备两个变量, 

```
    i       i - cn
1 : 变大    变大
2 : 不变    变大
3 : 变大    不变
```
i的值最多去到M, 两个变量合起来不超过2M, M<=N, 所以整个算法合起来还是O(N)

```
        while(i < ms.length){
            if (ms[i - 1] == ms[cn]){//为什么是ms[i - 1], 我们现在求i位置元素的前后缀, 而要判断i位置前一个元素(后缀末尾元素)和前缀末尾元素是否相等
                next[i++] = ++cn;//如果相等的话, 证明前后缀相等, 把++cn这个代表前缀子串长度的值填入next[i], 同时i++了, cn也同时移动到下一个前缀的末尾, 超级妙这句.
            }else if (cn > 0){//进行到这证明ms[i-1]!=ms[cn], 我们拿到cn位置的next值, 再重新进入循环看能不能求得前后缀子串.
                cn = next[cn];
            }else{
                next[i++] = 0;//来到这里证明i位置没有前后缀子串, 求下一个位置.
            }
        }

```
> 如果有疑问两个变量是怎么来的, 这个是我们人为造的, 它能描述整个while循环执行的次数, 这是一种常用的数学手段. 