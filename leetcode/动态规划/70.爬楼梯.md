### 题目
> 假设你正在爬楼梯。需要 n 阶你才能到达楼顶。 每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？

##### 示例1:
```
输入： 2
输出： 2
解释： 有两种方法可以爬到楼顶。
1.  1 阶 + 1 阶
2.  2 阶
```

##### 示例2:
```
输入： 3
输出： 3
解释： 有三种方法可以爬到楼顶。
1.  1 阶 + 1 阶 + 1 阶
2.  1 阶 + 2 阶
3.  2 阶 + 1 阶
```

##### 我开始时的思路
> 开始打算用递归的方法求解, 由于爬楼梯的时候只有两种开始方式, 第一步跨1个台阶或者第一步跨2个台阶. 比如说现在要爬4层楼梯, 爬楼梯的方法总和f(n)由两种开始方法得到:  
a) 开始爬1个台阶, 爬剩余的n-1个台阶一共有f(n-1)种办法  
b) 开始爬2个台阶, 爬剩余的n-2个台阶一共有f(n-2)种办法  
所以得到递推公式f(n) = f(1) + f(2)  
还要抠终止条件:  
当n==1, 也就是只1个台阶的时候只有1种办法  
当n==2, 也就是有2个台阶时有2种办法, 爬两次1阶和爬一次2阶

```
public int climbStairs(int n){
    if(1 == n) return 1;
    if(2 == n) return 2;
    return climbStairs(n-2)+climbStairs(n-1);
}
```
> 但是leetcode没有让我通过, 说执行时间超时. 考虑到递归调用栈的时间比较就, 使用非递归的方式实现上面的代码, 原理是一样的.

```
public int climbStairs(int n){
    if(1 == n) return 1;
    if(2 == n) return 2;

    int pre = 2;
    int prepre = 1;
    int sum = 0;
    for(int i = 3; i <= n; i++){
        sum = pre + prepre;
        prepre = pre;
        pre = sum;
    }
    return sum;
}
```
> 上面非递归的实现时间复杂度O(n), 额外空间复杂度O(1)
